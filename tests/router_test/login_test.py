from contextlib import asynccontextmanager
import tomllib

import pytest
from faker import Faker
from fastapi import FastAPI
from httpx import codes
from pytest_mock import MockerFixture
from sqlalchemy.ext.asyncio import AsyncConnection
from starlette.testclient import TestClient

from apiserver.app_def import create_app
from apiserver.app_lifespan import State, safe_startup, define_code
from apiserver.data import Source
from apiserver.data.frame import Code
from apiserver.env import load_config
from auth.core.model import SavedState, FlowUser
from auth.data.context import LoginContext
from auth.data.schemad.user import UserOps
from router_test.test_util import GenUser, OpaqueValues, make_test_user
from store import Store
from test_resources import res_path


# @pytest.fixture(scope="session", autouse=True)
# def faker_seed():
#     return 2085203821


@pytest.fixture
def gen_user(faker: Faker):
    yield make_test_user(faker)


@pytest.fixture(scope="module")
def api_config():
    test_config_path = res_path.joinpath("testenv.toml")
    yield load_config(test_config_path)


@pytest.fixture(scope="module")
def make_dsrc(module_mocker: MockerFixture):
    dsrc_inst = Source()
    store_mock = module_mocker.MagicMock(spec=dsrc_inst.store)
    store_mock.db.connect = module_mocker.MagicMock(
        return_value=module_mocker.MagicMock(spec=AsyncConnection)
    )
    dsrc_inst.store = store_mock

    yield dsrc_inst


@pytest.fixture(scope="module")
def make_cd():
    cd = define_code()
    yield cd


@pytest.fixture(scope="module")
def lifespan_fixture(api_config, make_dsrc: Source, make_cd: Code):
    safe_startup(make_dsrc, api_config)

    @asynccontextmanager
    async def mock_lifespan(app: FastAPI) -> State:
        yield {"dsrc": make_dsrc, "cd": make_cd}

    yield mock_lifespan


@pytest.fixture(scope="module")
def app(lifespan_fixture):
    # startup, shutdown is not run
    apiserver_app = create_app(lifespan_fixture)
    yield apiserver_app


@pytest.fixture(scope="module")
def test_client(app):
    with TestClient(app=app) as test_client:
        yield test_client


@pytest.fixture(scope="module")
def test_values():
    test_values_pth = res_path.joinpath("test_values.toml")
    with open(test_values_pth, "rb") as f:
        test_values_dict = tomllib.load(f)

    yield test_values_dict


@pytest.fixture(scope="module")
def opq_val(test_values: dict):
    yield OpaqueValues.model_validate(test_values["opaque"])


def mock_login_start_context(
    test_user: GenUser,
    pw_file: str,
    server_setup: str,
    test_scope: str,
    test_auth_id: str,
    state_store: dict,
):
    class MockLoginContext(LoginContext):
        @classmethod
        async def get_apake_setup(cls, store: Store) -> str:
            return server_setup

        @classmethod
        async def get_user_auth_data(
            cls, store: Store, user_ops: UserOps, login_mail: str
        ) -> tuple[str, str, str, str]:
            if test_user.user_email == login_mail:
                return test_user.user_id, test_scope, pw_file, test_auth_id

        @classmethod
        async def store_auth_state(
            cls, store: Store, auth_id: str, state: SavedState
        ) -> None:
            state_store[auth_id] = state

    return MockLoginContext


def test_login(test_client, make_cd, gen_user: GenUser, opq_val: OpaqueValues):
    state_store = {}
    test_auth_id = "12345"
    test_scope = "some_scope another"

    make_cd.context.login_ctx = mock_login_start_context(
        gen_user,
        opq_val.correct_password_file,
        opq_val.server_setup,
        test_scope,
        test_auth_id,
        state_store,
    )

    req = {"email": gen_user.user_email, "client_request": opq_val.login_start_request}

    response = test_client.post("/login/start/", json=req)

    assert response.status_code == codes.OK
    saved_state = state_store[test_auth_id]
    assert saved_state.scope == test_scope
    assert saved_state.user_id == gen_user.user_id
    assert saved_state.user_email == gen_user.user_email
    # We cannot test for the actual state as this is randomly generated by the opaque library


def mock_login_finish_context(
    test_user: GenUser, test_state: str, test_scope: str, flow_store: dict
):
    class MockLoginContext(LoginContext):
        @classmethod
        async def get_state(cls, store: Store, auth_id: str) -> SavedState:
            return SavedState(
                user_id=test_user.user_id,
                state=test_state,
                scope=test_scope,
                user_email=test_user.user_email,
            )

        @classmethod
        async def store_flow_user(
            cls, store: Store, session_key: str, flow_user: FlowUser
        ) -> None:
            flow_store[session_key] = flow_user

    return MockLoginContext


def test_finish_login(test_client, make_cd, gen_user: GenUser, opq_val: OpaqueValues):
    flow_store = {}
    test_auth_id = "15dae3786b6d0f20629cf"
    test_scope = "new_scope triple another"
    flow_id = "df60854e55352c9ff02f768a888710c3"
    # password 'clientele' with mock_opq_key
    test_state = opq_val.login_start_state

    make_cd.context.login_ctx = mock_login_finish_context(
        gen_user, test_state, test_scope, flow_store
    )

    # password 'clientele'
    req = {
        "email": gen_user.user_email,
        "client_request": "28gMIH7k8inGBdiMrpKidOtwtbcUlgMkmRNGVBy6CrXF_XPtVbzCwmtVCeUEuTSeRkyKFqDnD-v9AXcEfPUZ1w",
        "auth_id": test_auth_id,
        "flow_id": flow_id,
    }
    session_key = "_T2zjgIvJvYOFk4CnBMMhxl8-NXXstkHrVh9hpyvsOeNHt5nYubz_auzTxlzifiOkyKr1PbaeQd-d_S58MExNQ"

    response = test_client.post("/login/finish/", json=req)

    flow_user = flow_store[session_key]
    assert response.status_code == codes.OK
    assert flow_user.flow_id == flow_id
    assert flow_user.scope == test_scope
