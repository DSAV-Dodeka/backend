User: the person logging in

Web: the front-end JavaScript environment

Server: the back-end Python server connected to a database

**OAuth 2.0 terminology**

Resource Owner: Entity that can grant access to a protected resource. Typically, this is the end-user. **User**

Client: Application requesting access to a protected resource on behalf of the Resource Owner. **Web App**

Resource Server: Server hosting the protected resources. This is the API you want to access. **Server**

Authorization Server: Server that authenticates the Resource Owner and issues Access Tokens after getting proper authorization. In this case, Auth0. **Server**

User Agent: Agent used by the Resource Owner to interact with the Client (for example, a browser or a native application). -> **Browser**

*We will use Authorization Code Flow with Proof Key for Code Exchange (PKCE)* as recommended by the newest OAuth standard. However, as our resource server and auth server are one and the same, *and* because we also use the web application for the login prompt, we are missing some security benefits of this method and it most likely reduces to a less secure method. However, doing it this way makes it easier to refactor for an external ID/Auth provider if necessary in the future.

**Steps**

https://auth0.com/docs/authorization/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce
https://images.ctfassets.net/cdy7uua7fh8z/3pstjSYx3YNSiJQnwKZvm5/33c941faf2e0c434a9ab1f0f3a06e13a/auth-sequence-auth-code-pkce.png
https://www.oauth.com/oauth2-servers/pkce/authorization-request/

The User clicks the login link. Before they are sent to a login page, the following happens (on an invisible web page):

The Web App generates a *code verifier* (random string using A-Z, a-z, 0-9 and (hypen, period, underscore, tilde) of 43-128 characters.

Base64-url-encoded (from now on b64u-encoded) SHA256 hash of code verifier = *code challenge*. 

We also generate random state, which can also include some previous state information of the webpage the User was previously on, as long as the overall string is random. 

We save the code verifier and state locally in the Web App.

We then redirect the user to a server link along with the following:

```json
{
    "response_type": "code", # indicates that your server expects to receive an authorization code
    "client_id":  "dodekaweb", # Unique ID of the Web App
    "redirect_uri":  "dsavdodeka.nl/redirect", # Indicates the URL to return the user to after authorization is complete, this must be registered beforehand
    "state": "1234zyx", # A random string generated by your application, which youâ€™ll verify later
    "code_challenge": "somelonghash", # The code challenge generated as previously described,
    "code_challenge_method": "S256", # either plain or S256, depending on whether the challenge is the plain verifier string or the SHA256 hash of the string. If this parameter is omitted, the server will assume plain.
}
```

The Server stores all this information as it waits for the next step. This info is stored in a Key-Value server with JSON module, which allows it to read and write this data extremely quickly. *The key used to store it is a unique "authorization_id"*. The data is set to expire after a few minutes.

//TODO look at using different login page/server

Now, the User is redirected to the login page on the Web App, *with a unique authorization id*. This page is of the Server's choosing. Ideally you would not use the Web App for this, but an external app. 

On the login page, they enter their user ID and password, the password is hashed. The Web redirects to the User to the Server *(and sends the unique authorization id)*, which validates it against the database and redirects the user to the redirect_uri, with the following as `code` query parameter, encoded as a signed JWT (with associated sub, iat, etc.):

```json
{
    "client_id": "dodekaweb", # The client ID (or other client identifier) that requested this code
    "redirect_uri": "dsavdodeka.nl/redirect", # The redirect URL that was used. This needs to be stored since the access token request must contain the same redirect URL for verification when issuing the access token.
    "user_id": "54-32-48-80",# User ID
    "experation": "60 s",# Time when the code expires, probably best to keep 30-60 seconds, max 10 minutes
    "authorization_id": "someauthrequest", # Unique ID associated with the authorization code
}
```

The server loads the state value using the authorization_id from Key-Value and uses it as a query parameter, so the user is sent to i.e. `dsavdodeka.nl/redirect?code=LONGJWTOFTHEABOVE&state=ABCDEFGH`.

Now the Web App compares the state in the query with the state they initially sent. If they match, the response is accepted and the authorization code saved. 

To get an access token, the User now sends the following request:

```json
{
    "response_type": "authorization_code", # Indicates the grant type of this token request
    "code": "LONGJWTOFTHEABOVE", # The client will send the authorization code it obtained in the redirect
    "client_id":  "dodekaweb", # The client ID you received when you first created the application
    "redirect_uri":  "dsavdodeka.nl/redirect", # The redirect URL that was used in the initial authorization request
    "code_verifier": "textnothashed", # The code verifier for the PKCE request, that the app originally generated before the authorization request.
}
```

The Server checks the code signature (as it was a JWT) and computes the hash of the code verifier and compares this with the code challenge sent initially. If everything matches, it generates an access token and refresh token. It also explicitly matches the redirect_uri with the uri saved initially in the Key-Value for the authorization_id in the code.

The access tokens are self-encoded (they have all permission information), but have a short lifespan (1 hour). Refresh tokens have a lifespan of 1 year, but are not self-encoded.

Each user in the database is associated with valid refresh tokens, which can be revoked. 


**State**

The User has a **password**, associated with a **salt** and **password hash** on the Server **DB**. During the login, the User saves **state**, **code verifier**. The Server saves **state**, **redirect_uri** and **code challenge (computed by user from verifier)** at a Server-known **auth flow ID** on Server **KV**. The User then also saves **auth flow ID** and associates it with **state, etc.**. Server generates **auth code** for a specific **auth flow ID** based on matching **DB** credentials and sends it to redirect. Auth code is not saved at the server as it is server-signed and contains the auth code. The User then compares state and accepts the **auth code**. This **auth code** is then sent along with **redirect_uri** and original **code verifier** to Server, which matches everything and returns an **access token** and **refresh token**. The former is self-encoded and not stored by the Server, the latter is stored in **DB**.

